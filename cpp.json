{

"main file": {
	"prefix": "ashish",
	"body": [
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
	  "#define int long long",
	  "",
	  "int32_t main()",
	  "{",
	  "     ",
	  "     IOS;",
	  "     int T = 1; cin>>T;",
	  "     while (T--) {",
	  "",
	  "              int n; cin>>n;",
	  "              ",
	  "     }",
	  "",
	  "",
	  "     return 0;",
	  "}",
	  ""
	],
	"description": "template"
  } ,



  "sieve": {
	"prefix": "sieve",
	"body": [
	  "void sieve() ",
	  "{ ",
	  "   map<int,int> mp; //insert this outside",
	  "   ",
	  "",
	  "    int n = 1e6;",
	  "    bool prime[n+1]; ",
	  "    memset(prime, true, sizeof(prime)); ",
	  "  ",
	  "    for (int p=2; p*p<=n; p++) ",
	  "    { ",
	  "        if (prime[p] == true) ",
	  "        {  ",
	  "            for (int i=p*p; i<=n; i += p) ",
	  "                prime[i] = false; ",
	  "        } ",
	  "    } ",
	  "   ",
	  "    for (int p=2; p<=n; p++) ",
	  "       if (prime[p]) ",
	  "          cout << p << \" \"; ",
	  "}"
	],
	"description": "sieve"
  },


  "print all divisors": {
	"prefix": "divisors",
	"body": [
	  "void divisors(int n)",
	  "{",
	  "    vector<int> v;",
	  "",
	  "    for (int i = 1; i <= sqrt(n); i++) {",
	  "        if (n % i == 0) {",
	  "            if (i*i == n) ",
	  "                v.push_back(i);",
	  "            else {",
	  "               v.push_back(i);",
	  "               v.push_back(n/i);",
	  "            }",
	  "        }",
	  "    }",
	  "}"
	],
	"description": "List of all divisors"
  },

  "common bits": {
	"prefix": "bits",
	"body": [
	  "int commonbits(int a , int b){",
	  "     int ans = 0;",
	  "     for(int i = 0 ; i < 32 ; i ++){",
	  "",
	  "          if(  ( a & (1<<i) )  ==  (b & (1<<i))  ) ans++;",
	  "          ",
	  "          //perform any operation here",
	  "     }",
	  "",
	  "     return ans;",
	  "}"
	],
	"description": "common bits"
  },


  "graph": {
	"prefix": "graph",
	"body": [
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
	  "#define int long long",
	  "",
	  "",
	  "const int N = 1e5 + 5;",
	  "vector<int> arr[N+1];",
	  "int vis[N+1];",
	  "",
	  "",
	  "void insert(int u,int v)",
	  "{",
	  "  arr[u].push_back(v);",
	  "  arr[v].push_back(u);",
	  "}",
	  "",
	  "",
	  "void printallnodes(int n ){",
	  "          ",
	  "     for(int i=1; i<=n; i++)",
	  "     {",
	  "          cout<<i;   ",
	  "          for(auto x: arr[i])",
	  "          cout<<\"-> \"<<x;",
	  "                ",
	  "          cout<<\"\\n\";",
	  "     }",
	  "}",
	  "",
	  "void dfs(int k)",
	  "{",
	  "     vis[k]=1;",
	  "     cout<<k<<\" \";",
	  "     for(auto x : arr[k]) {",
	  "          if(!vis[x]) {",
	  "               //perform any operation here",
	  "               dfs(x);",
	  "          }",
	  "     }",
	  "     cout<<endl;",
	  "}",
	  "",
	  "void bfs(int k) {",
	  "     queue<int> s;",
	  "     s.push(1);",
	  "     int vis[N+5];",
	  "     memset(vis,0,sizeof(vis));",
	  "     while ((s.size()))",
	  "     {",
	  "          int here = s.front();",
	  "          cout<<here<<\" \";",
	  "          s.pop();",
	  "          for(auto x : arr[here]) {",
	  "               if(!vis[x]) {",
	  "                    vis[x] = 1;",
	  "                    s.push(x);",
	  "               }",
	  "          }",
	  "     }",
	  "}",
	  "",
	  "",
	  "",
	  "int32_t main()",
	  "{",
	  "     ",
	  "     IOS;",
	  "     int T = 1; //cin>>T;",
	  "     while (T--) {",
	  "          ",
	  "          int n;",
	  "          cin>>n;",
	  "          arr->clear();",
	  "          memset(vis,0,sizeof(vis));",
	  "",
	  "",
	  "          for(int i = 1 ; i < n ; i++ ) {",
	  "               int u,v;",
	  "               cin>>u>>v;",
	  "               insert(u,v);  //make sure to start from 1",
	  "          }",
	  "",
	  "          printallnodes(n);",
	  "          bfs(1); cout<<endl;",
	  "          dfs(1); ",
	  "     }",
	  "     return 0;",
	  "}"
	],
	"description": "graph"
  },


  "segmenttree": {
	"prefix": "segmenttree",
	"body": [
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
	  "#define int long long",
	  "",
	  "//Ashishgup ORZ",
	  "const int N=1e5+5;",
	  "",
	  "int a[N], d[N], st[4*N];",
	  " ",
	  "void build(int node, int L, int R)",
	  "{",
	  " if(L==R)",
	  " {",
	  "     st[node]=a[L];",
	  "     return;",
	  " }",
	  " int M=(L+R)>>1;",
	  " build(node*2, L, M);",
	  " build(node*2 + 1, M+1, R);",
	  " st[node]=st[node*2] * st[node*2+1];",
	  "}",
	  " ",
	  "int query(int node, int L, int R, int i, int j)",
	  "{",
	  " if(j<L || i>R)",
	  "     return 1;",
	  " if(i<=L && R<=j)",
	  "     return st[node];",
	  " int M=(L+R)>>1;",
	  " int left=query(node*2, L, M, i, j);",
	  " int right=query(node*2 + 1, M+1, R, i, j);",
	  " return left * right;",
	  "}",
	  " ",
	  "void update(int node, int L, int R, int pos, int val)",
	  "{",
	  " if(L==R)",
	  " {",
	  "     st[node]=val;",
	  "     return;",
	  " }",
	  " int M=(L+R)>>1;",
	  " if(pos<=M)",
	  "     update(node*2, L, M, pos, val);",
	  " else",
	  "     update(node*2 + 1, M+1, R, pos, val);",
	  " st[node]=st[node*2] * st[node*2+1];",
	  "}",
	  " ",
	  "",
	  "",
	  "int32_t main()",
	  "{",
	  "     ",
	  "     IOS;",
	  "     int T = 1; //cin>>T;",
	  "     while (T--) {",
	  "",
	  "              int n; cin>>n;",
	  "              for(int i = 1 ; i <= n ; i ++) cin>>a[i];",
	  "              build(1,1,n);",
	  "              int q; cin>>q;",
	  "              while (q--)",
	  "              {",
	  "                  int type,l,r; cin>>type>>l>>r;",
	  "                  if(type == 1) {",
	  "                      update(1,1,n,l,r);",
	  "                  }",
	  "                  else {",
	  "                      cout<<query(1,1,n,l,r)<<\"\\n\";",
	  "                  }",
	  "              }",
	  "              ",
	  "     }",
	  "     return 0;",
	  "}",
	  ""
	],
	"description": "segmenttree"
  },

  "fenwick": {
	"prefix": "fenwick",
	"body": [
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
	  "#define int long long",
	  "",
	  "const int N = 1e5 + 5;",
	  "int BIT[N];",
	  "",
	  "int getSum(int index) ",
	  "{",
	  "   int sum = 0; ",
	  "   while (index) ",
	  "   { ",
	  "       sum += BIT[index];   ",
	  "       index -= index & (-index);  ",
	  "       //this turns off the last set BIT which eventually gives the parent index",
	  "   }  ",
	  "   return sum; ",
	  "} ",
	  "",
	  "void updateBIT(int n, int index, int val) ",
	  "{ ",
	  "    while (index <= n) ",
	  "    { ",
	  "      BIT[index] += val; ",
	  "      index += index & (-index);",
	  "    } ",
	  "}",
	  "",
	  "",
	  "//use this when there are update queries also",
	  "void updateBIT1(int n, int index, int val , int old) ",
	  "{ ",
	  "    while (index <= n) ",
	  "    { ",
	  "      BIT[index] -= old;",
	  "      BIT[index] += val; ",
	  "      index += index & (-index);",
	  "    } ",
	  "}",
	  "",
	  "",
	  "int32_t main()",
	  "{",
	  "     ",
	  "     IOS;",
	  "     int T = 1; cin>>T;",
	  "     while (T--) {",
	  "",
	  "              int n; cin>>n;",
	  "              int v[n+1];",
	  "              for(int i = 0 ; i <= n ; i ++) BIT[i]  = 0;",
	  "",
	  "              for(int i = 1 ; i <= n  ; i ++ ) {",
	  "                  cin>>v[i];",
	  "                  updateBIT(n, i, v[i]);",
	  "              }",
	  "",
	  "              updateBIT1(n,3,100,BIT[3]);  //when the value at index 3 needs to be upated ",
	  "              ",
	  "              int ans = getSum(4);   //it basically means from 1 to 4",
	  "              cout<<ans<<endl;",
	  "              ",
	  "              //to get random ones , just do thier difference",
	  "              ans = getSum(5) - getSum(2);",
	  "              cout<<ans;",
	  "      ",
	  "     }",
	  "     return 0;",
	  "}"
	],
	"description": "fenwick"
  },

  "debug": {
	"prefix": "debug",
	"body": [
	  "void debug_out() { cerr << endl; }",
	  "",
	  "template <typename Head, typename... Tail>",
	  "void debug_out(Head H, Tail... T) {",
	  "  cerr << \" \" << to_string(H);",
	  "  debug_out(T...);",
	  "}",
	  "",
	  "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
	  ""
	],
	"description": "debug"
  },


  "conversion": {
	"prefix": "conversion",
	"body": [
	  "int conversion(){",
	  "",
	  "    //char to int",
	  "    char a = 'A';",
	  "    int num = int(a); //remove the int long long",
	  "    //here num will have value 65",
	  "    a= '2';",
	  "    int numm = a-48; //this will only work if the char is number already",
	  "    cout<<numm<<\"\\n\"<<num<<\"\\n\";",
	  "",
	  "    //char to string",
	  "    char b = 'B'; char c = 'C';",
	  "    string s;",
	  "    s.push_back(b); ",
	  "    s += c;",
	  "    cout<<s<<\"\\n\";",
	  "    //this is the simplest form of doing this",
	  "",
	  "",
	  "    //array of char to string",
	  "    char myarray[] = {\"Software Testing Help\"};",
	  "    string mystr(myarray);",
	  "     ",
	  "    cout<<mystr;",
	  "",
	  "",
	  "    //int to char",
	  "    int aa = 7;",
	  "    char cc = aa + 48;   ",
	  "    cout<<cc<<\"\\n\";   //this will only work for numbers between 0 to 9",
	  "}"
	],
	"description": "conversion"
  },

  "powmod": {
	"prefix": "powmod",
	"body": [
	  "int powmod(int a, int b, int m = 1e9 + 7) {",
	  " int r = 1;",
	  " while (b) {",
	  "     if (b & 1) r = r * int64_t(a) % m;",
	  "     a = int64_t(a) * int64_t(a) % m;",
	  "     b >>= 1;",
	  " }",
	  " return r;",
	  "}"
	],
	"description": "powmod"
  },
  
  "precision": {
	"prefix": "precision",
	"body": [
	  "cout<<fixed<<setprecision(16)<<ans;"
	],
	"description": "precision"
  },

  "kadane": {
	"prefix": "kadane",
	"body": [
	  "int kadane(vector<int>& nums) {",
	  "        int  maxtilnow=INT_MIN;",
	  "        int n=nums.size();",
	  "        int maxcurr=maxtilnow;",
	  "        for(int i=0;i<n;i++)",
	  "        {",
	  "          maxcurr=max(maxcurr+nums[i],nums[i]);",
	  "          maxtilnow=max(maxtilnow,maxcurr);",
	  "        }",
	  "        return maxtilnow;   ",
	  "}"
	],
	"description": "kadane"
  },
  
  "segmentedsieve": {
	"prefix": "segmentedsieve",
	"body": [
	  "void segmentedSieve(int L, int R) {",
	  "    int lim = sqrt(R);",
	  "    vector<bool> mark(lim + 1, false);",
	  "    vector<int> primes;",
	  "    for (int i = 2; i <= lim; ++i) {",
	  "        if (!mark[i]) {",
	  "            primes.emplace_back(i);",
	  "            for (int j = i * i; j <= lim; j += i)",
	  "                mark[j] = true;",
	  "        }",
	  "    }",
	  "",
	  "    vector<bool> isPrime(R - L + 1, true);",
	  "    for (int i : primes)",
	  "        for (int j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)",
	  "            isPrime[j - L] = false;",
	  "    if (L == 1)",
	  "        isPrime[0] = false;",
	  "    ",
	  "    for(int i=0;i<R-L+1;i+=1)",
	  "    {",
	  "        if(isPrime[i]==true)",
	  "            cout<<L+i<<\" \";",
	  "    }",
	  "    cout<<endl;",
	  "}"
	],
	"description": "segmentedsieve"
  },

  "nCr": {
	"prefix": "nCr",
	"body": [
	  "template<typename T> T pow(T a,T b, long long m){T ans=1; while(b>0){ if(b%2==1) ans=(ans*a)%m; b/=2; a=(a*a)%m; } return ans%m; }",
	  " ",
	  " ",
	  "const int N=1e6+5;",
	  "const int MOD=1e9+7;",
	  " ",
	  "int fact[N], invfact[N];",
	  " ",
	  "int modinv(int k)",
	  "{",
	  "    return pow(k, MOD-2, MOD);",
	  "}",
	  " ",
	  "void precompute()",
	  "{",
	  "    fact[0]=fact[1]=1;",
	  "    for(int i=2;i<N;i++)",
	  "    {",
	  "        fact[i]=fact[i-1]*i;",
	  "        fact[i]%=MOD;",
	  "    }",
	  "    invfact[N-1]=modinv(fact[N-1]);",
	  "    for(int i=N-2;i>=0;i--)",
	  "    {",
	  "        invfact[i]=invfact[i+1]*(i+1);",
	  "        invfact[i]%=MOD;",
	  "    }",
	  "}",
	  " ",
	  "int nCr(int x, int y)",
	  "{",
	  " int num=fact[x];",
	  " num*=invfact[y];",
	  " num%=MOD;",
	  " num*=invfact[x-y];",
	  " num%=MOD;",
	  " return num;",
	  "}"
	],
	"description": "nCr"
  },

  "comparater": {
	"prefix": "comparater",
	"body": [
	  "sort(v.begin(),v.end(), [] (const auto& lhs, const auto& rhs) { ",
	  "    if(lhs.second == rhs.second) return lhs.first > rhs.first;",
	  "    return lhs.second < rhs.second; ",
	  "    });"
	],
	"description": "comparater"
  },

  "stresstest.cpp": {
	"prefix": "stresstest.cpp",
	"body": [
	  "#include <bits/stdc++.h>",
	  "",
	  "using namespace std;",
	  "",
	  "const int N = 100005;",
	  "const int MOD = 1e9 + 7;",
	  "",
	  "#define show(arr) { for (auto x: arr) cerr << x << \" \"; cerr << '\\n'; }",
	  " ",
	  "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
	  "",
	  "int randNo(int lower_limit, int upper_limit){",
	  " ",
	  " return lower_limit + rng()%(upper_limit-lower_limit);",
	  "}",
	  "",
	  "int rand(int l, int r){",
	  "  uniform_int_distribution<int> ludo(l, r); return ludo(rng);",
	  "}",
	  "",
	  "string gen_string(int len = 0, bool upperCase = false, int l = 1, int r = 26) {",
	  "    assert(len >= 0 && len <= 5e6);",
	  "    string str(len, (upperCase ? 'A' : 'a'));",
	  "    for (char &ch: str) {",
	  "      ch += rand(l, r) - 1;",
	  "    }",
	  "    return str;",
	  "}",
	  "",
	  "vector<int> gen_array(int len = 0, int minRange = 0, int maxRange = INT_MAX ){",
	  "   assert(len >= 0 and len <= 5e6);",
	  "    vector<int> a(len);",
	  "    for (int &x: a) x = rand(minRange, maxRange);",
	  "    return a;",
	  "}",
	  "",
	  "//gen_array(10, -5, 10);",
	  "//it will return an array(vector more specifically) with length 10 and elements in the range [-5, 10].",
	  "",
	  "",
	  "int32_t permutation[N];",
	  "",
	  "vector<pair<int, int>> gen_tree(int n = 0){",
	  "    assert(n >= 0);",
	  "    vector<pair<int,int>> res(n ? n - 1 : 0);",
	  "    // if you like to have bamboo like tree or star like tree uncomment below 8 lines",
	  "    /*if (rng() % 5 == 0) { // bamboo like tree",
	  "      for (int i = 1; i < n; ++i) res[i-1] = {i, i + 1};",
	  "      return res;",
	  "    }",
	  "    if (rng() % 7 == 0) { // star tree",
	  "      for (int i = 2; i <= n; ++i) res[i-2] = {1, i};",
	  "      return res;",
	  "    }*/",
	  "    iota(permutation, permutation + 1 + n, 0);",
	  "    shuffle(permutation + 1, permutation + 1 + n, rng);",
	  "    for(int i = 2; i <= n; ++i){",
	  "      int u = i, v = rand(1 , i-1);",
	  "      u = permutation[u], v = permutation[v];",
	  "      res[i-2] = minmax(u, v); // u < v, just for convenience while debugging",
	  "    }",
	  "    shuffle(res.begin() , res.end() , rng);",
	  "    return res;",
	  "}",
	  "",
	  "",
	  "//gen_tree(10):",
	  "//will return a tree with 10 nodes.",
	  "",
	  "vector<pair<int, int>> simple_graph(int n = 0, int m = 0) {",
	  "    assert(n > 0 && m >= n);",
	  "    int max_edges = n * (n - 1) / 2;",
	  "    assert(m <= max_edges);",
	  "    vector<pair<int,int>> res = gen_tree(n);",
	  "    set<pair<int,int>> edge(res.begin(), res.end());",
	  "    for (int i = n; i <= m; ++i) {",
	  "      while (true) {",
	  "        int u = rand(1, n), v = rand(1, n);",
	  "        if (u == v) continue;",
	  "        auto it = edge.insert(minmax(u, v));",
	  "        if (it.second) break;",
	  "      }",
	  "    }",
	  "    res.assign(edge.begin(), edge.end());",
	  "    return res;",
	  "}",
	  "",
	  "//gen_simple_graph(10, 12);",
	  "//will return a simple connected graph with 10 nodes and 12 edges.",
	  "",
	  "",
	  "int solve(vector<int> s , int n) {",
	  " int ans = 0 ;",
	  "    return s.size();",
	  " //write here your optimed code with low complexity",
	  " ",
	  " return ans;",
	  "}",
	  "",
	  "int solve2(vector<int> s, int n) {",
	  " int ans = 0 ;",
	  " for(auto x : s) ans++;",
	  "",
	  " //write here your brute force solution",
	  " ",
	  " return 5;",
	  "}",
	  "",
	  "int32_t main() {",
	  " ",
	  " int testCases = 5;",
	  " while(testCases--){",
	  "     ",
	  "     //generating n",
	  "     int n = randNo(1,10);",
	  "",
	  "     string s = gen_string(5,1,1,26);",
	  "     vector<int> v = gen_array(n,0,10);",
	  "     //To generate a random array",
	  "     //int a[n];",
	  "     //for(int i=0;i<n;i++) a[i] = randNo(1,N);",
	  "     ",
	  "        //cerr<<s<<\"\\n\";",
	  "        show(v);",
	  "     int naive_ans = solve2(v,n);",
	  "     int optimised_ans = solve(v,n);",
	  "     ",
	  "     if(naive_ans == optimised_ans) continue; //cout << \"AC\\n\";",
	  "     else{",
	  "         cout << \"WA\\n\";",
	  "         cout << n << '\\n';",
	  "         show(v);",
	  "         cout << naive_ans << '\\n';",
	  "         cout << optimised_ans << '\\n';",
	  "         break;",
	  "     }",
	  " }",
	  "}"
	],
	"description": "stresstest.cpp"
  },



  
}
